<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Java – Objects & Classes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="../src/boostrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="../src/global/global.css" rel="stylesheet">

    <script type="text/javascript" src="../src/jquery-3.3.1.min.js"></script>
    <script type="text/javascript" src="../src/boostrap/js/bootstrap.min.js"></script>

    <script type="text/javascript" src="../src/global/global.js"></script>
</head>

<body class="bg-secondary">
<nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4">
    <a class="navbar-brand" href="#">Top navbar</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
                <a class="nav-link" href="#">Home <span class="sr-only">(current)</span></a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="#">Link</a>
            </li>
            <li class="nav-item">
                <a class="nav-link disabled" href="#">Disabled</a>
            </li>
        </ul>
        <form class="form-inline mt-2 mt-md-0">
            <input class="form-control mr-sm-2" type="text" placeholder="Search" aria-label="Search">
            <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
        </form>
    </div>
</nav>

<main role="main" class="container">
    <div class="introduction">
        <h1>Java – Objects & Classes</h1>
        <div class="lead">
            <p>Trong lesson này ta sẽ đi sơ qua về Object/ Class trong Java</p>
            <p>Các khái niệm từ đây sẽ được giữ nguyên để tránh các hiểu nhầm ko đáng có</p>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Java is an Object-Oriented Language</h3>
        <div class="text-muted pt-3">
            <p>Java là một ngôn ngữ hướng đối tượng. Mà đã là hướng đối tượng, thì nó phải hỗ trợ các khái niệm sau:</p>
            <ul>
                <li>Polymorphism</li>
                <li>Inheritance</li>
                <li>Encapsulation</li>
                <li>Abstraction</li>
                <li>Classes</li>
                <li>Objects</li>
                <li>Instance</li>
                <li>Method</li>
                <li>Message Parsing</li>
            </ul>

            <h4>Classes and Object</h4>

            <ul>
                <li> Objects have states and behaviors. Example: A dog has states - color, name, breed as well as
                    behaviors – wagging the tail, barking, eating. An object is an instance of a class. </li>

                <li>Class - A class can be defined as a template/blueprint that describes the behavior/state that the
                    object  of its type support. </li>
            </ul>

            <p>Chi tiết:</p>

            <ul>
                <li>
                    Object là những đối tượng. Nó bao gồm trạng thái và phương thức. Ta gọi Dog là một object, nó có
                    status là màu lông, tên, tuổi, với các phương thức là sủa, chạy đi, ăn .....<br />
                    <br />
                    Software Objects cũng tương tự như vậy. Nó cũng có states và behaviors. States thì được lưu trong các
                    fields và behavior thì được hiển thị thông qua các method.<br />
                    <br />
                    Các Objects tương tác với nhau thông qua các method.<br />
                    <br />
                    Các objects là thể hiện của 1 Class.
                </li>

                <li>
                    Class in Java là blueprint - tức là cái mẫu từ đó các đối tượng được tạo ra.<br />
                    <br />
                    Java sử dụng từ khóa <strong>new</strong> để tạo ra 1 object từ class đó. Ví dụ Color redColor = new Color("red");
                    <br />
                    Class có thể chứa các kiểu dữ liệu sau.
                    <ul>
                        <li><strong>Local variables</strong>: Variables defined inside methods, constructors or blocks
                            are called local variables. The variable will be declared and initialized within the method
                            and the variable  will be destroyed when the method has completed.</li>

                        <li><strong>Instance variables</strong>: Instance variables are variables within a class but
                            outside any method. These variables are initialized when the class is instantiated. Instance
                            variables can be accessed from inside any method, constructor or blocks of that particular
                            class.</li>

                        <li><strong>Class variables</strong>: Class variables are variables declared within a class,
                            outside any  method, with the static keyword.</li>
                    </ul>

                    <p>Chi tiết:</p>

                    <ul>
                        <strong>Local variables</strong> là các biến được định nghĩa bên trong method, và bị xóa đi
                        khi method được thực hiện xong bằng cái Garbage Component của Java. Ví dụ:

                        <blockquote>
                            function swapTwoNumber(int numberA, int numberB {<br />
                            &nbsp;&nbsp;&nbsp;&nbsp;int temp = numberA;<br />
                            }<br />
                            <br />
                            <i>temp là biến ở trong hàm, chỉ tồn tại ở trong hàm này thôi.</i>
                        </blockquote>

                        </li>

                        <li>
                            <p>Instance variables: Đây là các biến trong Class khi các Instance được khởi tạo. Nói
                                nôm na thì nó là các status của Instance. Ví dụ:</p>

                            <blockquote>
                                class ColorTemplate {<br />
                                &nbsp;&nbsp;&nbsp;&nbsp;private String color;<br />
                                }<br />
                                <br />
                                ColorTemplate redColor = new ColorTemplate("red");<br />
                                <br />
                                <i>redColor.color là biến tồn tại khi mà 1 Instance/ Object được tạo ra.</i>
                            </blockquote>
                        </li>

                        <li>Class variables: Đây là các biến của riêng Class, nó thuộc Class chứ ko phải thuộc các
                            Instance như trên kia. Thường thì những giá trị này được khai báo bằng từ khóa
                            <strong>static</strong> ở đầu. Ví dụ

                            <blockquote>
                                class ColorTemplate {<br />
                                &nbsp;&nbsp;&nbsp;&nbsp;public static const String VERSION_OF_CLASS = "123456";<br />

                                }<br />
                                <br />
                                <i>VERSION_OF_CLASS là biến của class, được gọi bằng cách ColorTemplate.VERSION_OF_CLASS</i>
                            </blockquote>
                        </li>
                    </ul>
                </li>
            </ul>

            <h4>Constructors</h4>
            <p>
                Tất cả class đều có 1 constructor. Nếu mà chúng ta không khai báo thì Java Compiler (javac) sẽ tạo ra 1
                constructor mặc định cho nó. Đây là điểm mà trước kia chưa biết. Luôn ghi nhớ, <strong style="text-transform: uppercase">tất cả
                class đều có
                Constructor.</strong>
            </p>
            <p>Mỗi thời điểm, khi mà 1 new Object được created, thì ít nhất 1 constructor sẽ được gọi (invoker). Quy tắc
                của constructor đó là nó phải có tên trùng với tên của Class. 1 Class có thể có nhiều hơn 1 constructor.</p>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Các method của class Class.</h3>
        <div class="text-muted pt-3">
            <table class="tab-content">
                <tbody>
                <tr>
                    <th>Methods</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><strong>public int hashCode()</strong></td>
                    <td>This method returns the <strong>hashcode</strong> of the java object.</td>
                </tr>
                <tr>
                    <td><strong>public boolean equals(Object obj)</strong></td>
                    <td>Compares the given object to this object.</td>
                </tr>
                <tr>
                    <td><strong>protected Object clone() throws CloneNotSupportedException</strong></td>
                    <td>This method <strong>creates</strong> and <strong>returns</strong> the exact copy (clone) of this object.</td>
                </tr>
                <tr>
                    <td><strong>public String toString()</strong></td>
                    <td>Returns the <strong>string representation</strong> of this object.</td>
                </tr>
                <tr>
                    <td><strong>public final Class getClass()</strong></td>
                    <td>Returns the <strong>Class</strong> class object of the object.</td>
                </tr>
                <tr>
                    <td><strong>public final void notify()</strong></td>
                    <td>This method wakes up a <strong>single thread</strong> that is waiting on this object’s monitor.</td>
                </tr>
                <tr>
                    <td><strong>public final void notifyAll()</strong></td>
                    <td>This method wakes up <strong>all threads</strong> that are waiting on this object’s monitor.</td>
                </tr>
                <tr>
                    <td><strong>public final void wait(long timeout)throws InterruptedException</strong></td>
                    <td>This method makes the current thread to <strong>wait</strong> for the specified milliseconds, until another thread notifies (invokes <strong>notify()</strong> or <strong>notifyAll()</strong> method).</td>
                </tr>
                <tr>
                    <td><strong>public final void wait(long timeout,int nanos)throws InterruptedException</strong></td>
                    <td>This method makes the current thread to wait for the specified miliseconds and nanoseconds, until another thread notifies (invokes <strong>notify()</strong> or <strong>notifyAll()</strong> method).</td>
                </tr>
                <tr>
                    <td><strong>public final void wait()throws InterruptedException</strong></td>
                    <td>This method makes&nbsp;the current thread to wait, until another thread notifies (invokes <strong>notify()</strong> or <strong>notifyAll()</strong> method).</td>
                </tr>
                <tr>
                    <td><strong>protected void finalize()throws Throwable</strong></td>
                    <td>This method is invoked by the <strong>garbage collector</strong> before object is being garbage collected.</td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Singleton Class</h3>
        <div class="text-muted pt-3">
            <p>Mục đích của Singleton đó là quản lý việc tạo các Object, giới hạn số lượng tạo Object về còn 1. </p>
            <p>Vì chỉ có 1 instance, nên mặc dù nó là object, nhưng ta có thể xem nó như là 1 filed của class, tương tự
                như static fields vậy.
            </p>
            <p>Singleton thường được sử dung trong việc quản lý truy cập vào các tài nguyên (resource), như là kết nối
                database, hoặc socket.</p>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Singleton Design Patten</h3>
        <div class="text-muted pt-3">
            <h4>Cách tạo</h4>
            <ul>
                <li>Dữ liệu thành viên (instance) <b>private</b> và <b>static</b> là đối tượng duy nhất của Class
                    Singleton</li>
                <li>Constructor của nó được khai báo thành <b>private</b> hoặc <b>static</b> để tránh việc tạo instance
                    từ ngoài class</li>
                <li>Khai báo 1 phương thức là getInstance() để khởi tạo đối tượng duy nhất, định nghĩa là <b>public</b>
                    và <b>static</b>. Client chỉ dùng getInstance() để tạo đối tượng cho lớp SingleTon.
                </li>
                <li>Thực hiện khởi tạo chậm (lazy initialization) trong getInstance() để chỉ tạo object khi thực sự cần
                    thiết.</li>

                <li><h4>Trong chế độ multithreading, mẫu thiết kế Singleton có thể làm việc không tốt: do getInstance()
                    không an toàn thread, hai thread có thể gọi phương thức sinh đối tượng cùng một thời điểm và hai thể
                    hiện sẽ được tạo ra. Nếu đồng bộ (synchronized) phương thức getInstance() để an toàn thread sẽ dẫn
                    đến  giảm hiệu suất  chương trình.</h4></li>
            </ul>
            <h4>Xem ví dụ trong JavaLesson02.</h4>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Singleton Trong Java</h3>
        <div class="text-muted pt-3">
            <ul>
                <li>Abstract Factory: thường là Singleton để trả về các đối tượng factory duy nhất.</li>
                <li>Builder: dùng để xây dựng một đối tượng phức tạp, trong đó Singleton được dùng để tạo một đối tượng
                    truy cập tổng quát (Director).</li>
                <li>Prototype: dùng để sao chép một đối tượng, hoặc tạo ra một đối tượng khác từ Prototype của nó, trong
                    đó  Singleton được dùng để chắc chắn chỉ có một Prototype.</li>
                <li>Trong Java API, Lớp java.lang.Runtime là lớp Singleton, để lấy được đối tượng duy nhất của nó, ta gọi
                    phương thức  getRuntime(). Tương tự, lớp java.awt.Desktop cũng là lớp Singleton, tạo đối tượng duy
                    nhất bằng phương thức getDesktop(). Singleton không phổ biến như ta nghỉ, nó chỉ áp dụng với lớp cần
                    bảo  đảm chỉ có một thể hiện duy nhất.</li>
            </ul>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Khi nào thì sử dụng singleton</h3>
        <div class="text-muted pt-3">
            <ul>
                <li>Đảm bảo rằng chỉ có một thể hiện của lớp.</li>
                <li>Quản lý việc truy cập tốt hơn vì chỉ có một thể hiện duy nhất.</li>
                <li>Quản lý số lượng thể hiện của một lớp. Trường hợp này không nhất thiết chỉ có một thể hiện, bạn cần kiểm soát số lượng thể hiện trong giớn hạn chỉ định.</li>
            </ul>
        </div>
    </div>

    <h2>Các cách tạo singleton.</h2>
    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Eager load</h3>
        <div class="text-muted pt-3">
            <p>Phương thức này khởi tạo instance ngay khi class được load.</p>

            <p>Hạn chế của nó, luôn phải sử dụng bộ nhớ để cấp phát cho cái thằng này mặc dù đôi khi không cần thiết</p>

            <p>Điều này làm việc load class chậm và tốn nhiều Ram (cho những instance phức tạp)</p>

            <p>Giải pháp: sử dụng Lazy-load để tạo object khi cần thiết.</p>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Lazy-load synchronized method.</h3>
        <div class="text-muted pt-3">
            <p>Phương thức này khởi tạo instance khi mà có 1 thread nào đó gọi method getInstance. Vì vậy instance
                đc tạo ra chỉ khi nào cần thiết</p>

            <p>Trong multiple thread, nó gặp vấn đề khi 2 thread cùng gọi tới 1 method này trong cùng 1 thời điểm.
                Để ngăn chặn điều đó, nó khai báo từ khóa synchronize để block các thread khác, đảm bảo chỉ có duy
                nhất 1 thread đc truy xuất đến nó trong cùng 1 thời điểm, và các thằng khác phải đợi khi thằng này
                chạy xong. Xem thêm về synchronized ở cuối bài</p>

            <p>Vì dùng synchronized nên nó có những nhược điểm sau:</p>

            <ul>
                <li>vì nó làm cho các method khác bị block nên làm giảm hiệu năng</li>

                <li>Chưa thực sự giải quyết được vấn đề của multiple thread, vẫn có khả năng xảy ra trường hợp 2
                    instance được gọi, khi mà cái điều kiện is null của nó bị vượt qua</li>
            </ul>

            <p>Giải pháp: sử dụng double check single ton</p>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Lazy Load Double check synchronized</h3>
        <div class="text-muted pt-3">
            <p>Mở rộng từ Lazy Load, Double check sử dụng 2 lần để kiểm tra synchronized.</p>

            <p>Nó không sử dụng synchronized ở bên ngoài function getInstance, mà chỉ check khi tạo ra object</p>

            <p style="text-transform: uppercase">Nó sử dụng từ khóa volatile để đồng bộ dữ liệu của instance giữa các thread.
                Đây là điểm  quan trọng nhất và cần ghi nhớ.</p>


            <p>Xem method <b>getDoubleCheckSynchronizedSingleton</b> để hiểu thêm.</p>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Initialization on Demand Holder (Design pattern) - Cái này là OK nhất.</h3>
        <div class="text-muted pt-3">
            <p>Java đảm bảo tính an toàn khi chạy đa luồng cho static class loader. Do vậy, chúng ta không cần quan
                tâm tới double check nữa , mà chỉ quan tâm tới cách mà chúng ta khởi tạo instance thôi.</p>

            <p>Cách tiếp cận này như sau:</p>

            <ol>
                <li>
                    Khai báo 1 private static class loader
                    <blockquote>
                        private static class LazyHolder {<br />
                        &nbsp;&nbsp;&nbsp;&nbsp;static final Singleton lazyHolderInstance = new Singleton();<br />
                        }<br />
                    </blockquote>
                </li>
                <li>
                    Trong function getInstance, ta sử dụng static class kia để get instance của nó ra

                    <blockquote>
                        public static Singleton getLazyHolderInstance() {<br />
                        &nbsp;&nbsp;&nbsp;&nbsp;return LazyHolder.lazyHolderInstance;<br />
                        }<br />
                    </blockquote>
                </li>
            </ol>
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Sử dụng ENUM<</h3>
        <div class="text-muted pt-3">
            BODY_CONTENT MUST BE REVISE LATER.
        </div>
    </div>

    <div class="my-4 p-3 bg-white rounded box-shadow">
        <h3 class="border-bottom border-gray pb-2 mb-0">Tài liệu tham khảo</h3>
        <div class="text-muted pt-3">
            <ul>
                <li>
                    * <a href="https://viblo.asia/p/java-synchronized-blocks-jlA7GK04vKZQ">Synchronized trong Java</a>
                    <p>Synchronized blocks trong Java được thể hiện qua từ khóa synchronized. Một khối đồng bộ trong Java được đồng
                        bộ trên các object. Tất cả các khối đồng bộ được đồng bộ trên cùng một object có thể có một thread được
                        thực  thi trong chúng trên cùng một thời điểm. Toàn bộ các thread khác khi cố gắng tham gia vào khối đồng
                        bộ đều bị chặn lại cho tới khi thread bên trong khối xử lý không còn tồn tại.</p>
                </li>
                <li>
                    ** <a href="https://huongdanjava.com/vi/noi-ve-bien-volatile-trong-java.html">Volatile trong Java</a>
                    <p>Biến volatile trong Java có tác dụng thông báo sự thay đổi giá trị của biến tới các thread khác nhau
                        nếu  biến này đang được sử dụng trong nhiều thread.</p>
                </li>
                <li>
                    *** <a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom">Demand Holder</a>
                    <p>

                    </p>
                </li>
                <li>
                    * <a href="https://tech.fpt.com.vn/design-pattern-singleton/">Singleton design pattern.</a>
                </li>

            </ul>
        </div>
    </div>
</main>

<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <a class="btn btn-default float-lg-left" href="lesson_01.html">
                    Java - Basic
                </a>

                <a class="btn btn-default float-lg-right" href="lesson_03.html">
                    Java – Objects & Classes (Lesson 3)
                </a>
            </div>
        </div>
    </div>

    <br class="clearfix"/>

    <div class="container">
        <span class="text-muted">
            <address>
            Created by <strong>Khanh Tran</strong><br>
            Email: quockhanhqb011@gmail.com<br>
            Phone: (+84) 989 890 960
        </address>
        </span>
    </div>
</footer>
</body>
</html>